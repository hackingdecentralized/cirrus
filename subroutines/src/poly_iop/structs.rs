// Copyright (c) 2023 Espresso Systems (espressosys.com)
// This file is part of the HyperPlonk library.

// You should have received a copy of the MIT License
// along with the HyperPlonk library. If not, see <https://mit-license.org/>.

//! This module defines structs that are shared by all sub protocols.

use arithmetic::{OnDiskPolynomial, VirtualPolynomial};
use ark_ff::PrimeField;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Write};
use std::fs::{File, OpenOptions};
use std::io::{BufReader, BufWriter};
use std::path::PathBuf;
use crate::PolyIOPErrors;

/// An IOP proof is a collections of
/// - messages from prover to verifier at each round through the interactive
///   protocol.
/// - a point that is generated by the transcript for evaluation
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct IOPProof<F: PrimeField> {
    pub point: Vec<F>,
    pub proofs: Vec<IOPProverMessage<F>>,
}

/// A message from the prover to the verifier at a given round
/// is a list of evaluations.
#[derive(Clone, Debug, Default, PartialEq, Eq, CanonicalSerialize, CanonicalDeserialize)]
pub struct IOPProverMessage<F: PrimeField> {
    pub(crate) evaluations: Vec<F>,
}

/// Prover State of a PolyIOP.
pub struct IOPProverState<F: PrimeField> {
    /// sampled randomness given by the verifier
    pub challenges: Vec<F>,
    /// the current round number
    pub(crate) round: usize,
    /// pointer to the virtual polynomial
    pub(crate) poly: VirtualPolynomial<F>,
    /// points with precomputed barycentric weights for extrapolating smaller
    /// degree uni-polys to `max_degree + 1` evaluations.
    pub(crate) extrapolation_aux: Vec<(Vec<F>, Vec<F>)>,
}

#[derive(Clone, CanonicalSerialize, CanonicalDeserialize)]
pub struct OnDiskIOPProverState<F: PrimeField> {
    /// sampled randomness given by the verifier
    pub challenges: Vec<F>,
    /// the current round number
    pub(crate) round: usize,
    /// pointer to the virtual polynomial
    pub(crate) poly: OnDiskPolynomial<F>,
    /// points with precomputed barycentric weights for extrapolating smaller
    /// degree uni-polys to `max_degree + 1` evaluations.
    pub(crate) extrapolation_aux: Vec<(Vec<F>, Vec<F>)>,
}

impl<F: PrimeField> OnDiskIOPProverState<F> {
    pub fn store(self, path: &PathBuf) -> Result<(), PolyIOPErrors> {
        // 1) Open or create the file for writing
        let file = OpenOptions::new()
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| PolyIOPErrors::InvalidParameters(format!("I/O error: {e}")))?;

        let mut writer = BufWriter::new(file);

        // 2) Call the appropriate Arkworks serialization method
        self.serialize_compressed(&mut writer)
            .map_err(|e| PolyIOPErrors::InvalidParameters(format!("Serialize error: {e}")))?;

        // 3) Flush the writer just to be safe
        writer.flush().map_err(|e| {
            PolyIOPErrors::InvalidParameters(format!("Flush error after writing polynomial: {e}"))
        })?;

        Ok(())
    }

    pub fn load(path: &PathBuf) -> Result<Self, PolyIOPErrors> {
        let file = File::open(path)
        .map_err(|e| PolyIOPErrors::InvalidParameters(format!("I/O error: {e}")))?;
        let mut reader: BufReader<File> = BufReader::new(file);

        let ondisk_state = {
            {
                OnDiskIOPProverState::<F>::deserialize_compressed(&mut reader)
                    .map_err(|e| PolyIOPErrors::InvalidParameters(format!("Deserialize error: {e}")))?
            }
        };
        
        Ok(ondisk_state)
    }
}

impl<F: PrimeField> From<OnDiskIOPProverState<F>> for IOPProverState<F> {
    fn from(ondisk_state: OnDiskIOPProverState<F>) -> Self {
        IOPProverState {
            challenges: ondisk_state.challenges,
            round: ondisk_state.round,
            poly: ondisk_state.poly.into(),
            extrapolation_aux: ondisk_state.extrapolation_aux,
        }
    }
}

impl<F: PrimeField> From<IOPProverState<F>> for OnDiskIOPProverState<F> {
    fn from(ondisk_state: IOPProverState<F>) -> Self {
        OnDiskIOPProverState {
            challenges: ondisk_state.challenges,
            round: ondisk_state.round,
            poly: ondisk_state.poly.into(),
            extrapolation_aux: ondisk_state.extrapolation_aux,
        }
    }
}

/// Prover State of a PolyIOP
pub struct IOPVerifierState<F: PrimeField> {
    pub(crate) round: usize,
    pub(crate) num_vars: usize,
    pub(crate) max_degree: usize,
    pub(crate) finished: bool,
    /// a list storing the univariate polynomial in evaluation form sent by the
    /// prover at each round
    pub(crate) polynomials_received: Vec<Vec<F>>,
    /// a list storing the randomness sampled by the verifier at each round
    pub(crate) challenges: Vec<F>,
}
